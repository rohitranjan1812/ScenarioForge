// Graph Utilities Tests

import { describe, it, expect } from 'vitest';
import {
  createGraph,
  createNode,
  createEdge,
  addNode,
  addEdge,
  removeNode,
  removeEdge,
  validateGraph,
  topologicalSort,
  cloneGraph,
  exportGraph,
  importGraph,
} from './index.js';
import type { CreateNodeInput, CreateEdgeInput, Graph } from '../types/index.js';

describe('Graph Utilities', () => {
  describe('createGraph', () => {
    it('should create an empty graph', () => {
      const graph = createGraph({
        name: 'Test Graph',
        description: 'A test graph',
      });

      expect(graph.id).toBeDefined();
      expect(graph.name).toBe('Test Graph');
      expect(graph.description).toBe('A test graph');
      expect(graph.nodes).toEqual([]);
      expect(graph.edges).toEqual([]);
      expect(graph.version).toBe(1);
    });
  });

  describe('createNode', () => {
    it('should create a node with default values', () => {
      const input: CreateNodeInput = {
        type: 'CONSTANT',
        name: 'Node 1',
        position: { x: 100, y: 100 },
      };
      
      const node = createNode(input);

      expect(node.id).toBeDefined();
      expect(node.type).toBe('CONSTANT');
      expect(node.name).toBe('Node 1');
      expect(node.position).toEqual({ x: 100, y: 100 });
      expect(node.inputPorts).toEqual([]);
      expect(node.outputPorts).toEqual([]);
    });
  });

  describe('addNode', () => {
    it('should add a node to a graph', () => {
      const graph = createGraph({ name: 'Test', description: 'Test graph' });
      
      const nodeInput: CreateNodeInput = {
        type: 'CONSTANT',
        name: 'Node 1',
        position: { x: 0, y: 0 },
      };

      const updatedGraph = addNode(graph, nodeInput);

      expect(updatedGraph.nodes).toHaveLength(1);
      expect(updatedGraph.nodes[0].name).toBe('Node 1');
      expect(updatedGraph.nodes[0].type).toBe('CONSTANT');
      // Original graph should be unchanged (immutability)
      expect(graph.nodes).toHaveLength(0);
    });
  });

  describe('addEdge', () => {
    it('should add an edge between nodes with valid ports', () => {
      let graph = createGraph({ name: 'Test', description: 'Test graph' });
      
      // Create nodes with ports (id is ignored, system generates new IDs)
      const node1Input: CreateNodeInput = {
        type: 'CONSTANT',
        name: 'Source',
        position: { x: 0, y: 0 },
        outputPorts: [{ name: 'output', dataType: 'number', required: false, multiple: false }],
      };
      
      const node2Input: CreateNodeInput = {
        type: 'OUTPUT',
        name: 'Target',
        position: { x: 100, y: 0 },
        inputPorts: [{ name: 'input', dataType: 'number', required: false, multiple: false }],
      };
      
      graph = addNode(graph, node1Input);
      graph = addNode(graph, node2Input);
      
      const sourceNode = graph.nodes[0];
      const targetNode = graph.nodes[1];
      
      // Port IDs are generated by the system, so get actual port IDs
      const edgeInput: CreateEdgeInput = {
        sourceNodeId: sourceNode.id,
        sourcePortId: sourceNode.outputPorts[0].id,
        targetNodeId: targetNode.id,
        targetPortId: targetNode.inputPorts[0].id,
      };
      
      const updatedGraph = addEdge(graph, edgeInput);

      expect(updatedGraph.edges).toHaveLength(1);
      expect(updatedGraph.edges[0].sourceNodeId).toBe(sourceNode.id);
      expect(updatedGraph.edges[0].targetNodeId).toBe(targetNode.id);
    });

    it('should throw when source node not found', () => {
      const graph = createGraph({ name: 'Test', description: '' });
      
      expect(() => addEdge(graph, {
        sourceNodeId: 'nonexistent',
        sourcePortId: 'out',
        targetNodeId: 'also-nonexistent',
        targetPortId: 'in',
      })).toThrow('Source node nonexistent not found');
    });
  });

  describe('removeNode', () => {
    it('should remove a node from a graph', () => {
      let graph = createGraph({ name: 'Test', description: '' });
      graph = addNode(graph, { type: 'CONSTANT', name: 'Node 1', position: { x: 0, y: 0 } });
      
      const nodeId = graph.nodes[0].id;
      const updatedGraph = removeNode(graph, nodeId);
      
      expect(updatedGraph.nodes).toHaveLength(0);
    });
  });

  describe('validateGraph', () => {
    it('should validate a valid graph', () => {
      const graph = createGraph({ name: 'Test', description: '' });
      const result = validateGraph(graph);
      
      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should return valid=true for empty graph', () => {
      const graph = createGraph({ name: 'Empty', description: '' });
      const result = validateGraph(graph);
      
      expect(result.valid).toBe(true);
    });
  });

  describe('topologicalSort', () => {
    it('should sort a simple graph', () => {
      let graph = createGraph({ name: 'Test', description: '' });
      graph = addNode(graph, { 
        type: 'CONSTANT', 
        name: 'A', 
        position: { x: 0, y: 0 },
        outputPorts: [{ name: 'out', dataType: 'number', required: false, multiple: false }],
      });
      graph = addNode(graph, { 
        type: 'OUTPUT', 
        name: 'B', 
        position: { x: 100, y: 0 },
        inputPorts: [{ name: 'in', dataType: 'number', required: false, multiple: false }],
      });
      
      const nodeA = graph.nodes[0];
      const nodeB = graph.nodes[1];
      
      // Get actual port IDs generated by the system
      graph = addEdge(graph, {
        sourceNodeId: nodeA.id,
        sourcePortId: nodeA.outputPorts[0].id,
        targetNodeId: nodeB.id,
        targetPortId: nodeB.inputPorts[0].id,
      });
      
      const sorted = topologicalSort(graph);
      
      expect(sorted).not.toBeNull();
      expect(sorted).toHaveLength(2);
      // A should come before B since A -> B
      const indexA = sorted!.findIndex(n => n.id === nodeA.id);
      const indexB = sorted!.findIndex(n => n.id === nodeB.id);
      expect(indexA).toBeLessThan(indexB);
    });
  });

  describe('cloneGraph', () => {
    it('should create a deep copy with new IDs', () => {
      let graph = createGraph({ name: 'Original', description: '' });
      graph = addNode(graph, { type: 'CONSTANT', name: 'Node', position: { x: 0, y: 0 } });
      
      const cloned = cloneGraph(graph);

      expect(cloned.id).not.toBe(graph.id);
      expect(cloned.name).toBe('Original (Copy)');
      expect(cloned.nodes).toHaveLength(1);
      expect(cloned.nodes[0].id).not.toBe(graph.nodes[0].id);
      expect(cloned.nodes[0].name).toBe('Node');
    });
  });

  describe('exportGraph / importGraph', () => {
    it('should export and import a graph', () => {
      let graph = createGraph({ name: 'Test', description: 'Export test' });
      graph = addNode(graph, { 
        type: 'CONSTANT', 
        name: 'Node 1', 
        position: { x: 0, y: 0 },
        data: { value: 42 },
      });

      const exported = exportGraph(graph);
      const imported = importGraph(exported);

      expect(imported.name).toBe('Test');
      expect(imported.description).toBe('Export test');
      expect(imported.nodes).toHaveLength(1);
      expect(imported.nodes[0].name).toBe('Node 1');
      expect(imported.nodes[0].data.value).toBe(42);
    });
  });
});
